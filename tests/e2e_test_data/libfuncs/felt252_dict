//! > felt252_dict_new libfunc

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo() -> Felt252Dict::<felt252> {
    felt252_dict_new::<felt252>()
}

//! > casm
%{
if '__dict_manager' not in globals():
    from starkware.cairo.common.dict import DictManager
    __dict_manager = DictManager()

if '__segment_index_to_arena_index' not in globals():
    # A map from the relocatable value segment index to the index in the
    # arena.
    __segment_index_to_arena_index = {}

# memory[fp + -3] is the address of the next SegmentArenaBuiltin.
# memory[memory[fp + -3] - 2] is the number of allocated segments.
index = memory[memory[fp + -3] - 2]

segment_start = __dict_manager.new_default_dict(
    segments, 0, temp_segment=index > 0
)

# Update '__segment_index_to_arena_index'.
__segment_index_to_arena_index[segment_start.segment_index] = index

# Update 'SegmentInfo::start'.
# memory[memory[fp + -3] - 3] is the address of the segment arena infos
# segment. index * 3 is added to get the address of the new SegmentInfo.
memory[memory[memory[fp + -3] - 3] + index * 3] = segment_start
%}
[ap + 0] = [[fp + -3] + -3], ap++;
[ap + 0] = [[fp + -3] + -2], ap++;
[ap + 0] = [[fp + -3] + -1], ap++;
[ap + -3] = [[fp + -3] + 0];
[ap + 0] = [ap + -2] + 1, ap++;
[ap + -1] = [[fp + -3] + 1];
[ap + -2] = [[fp + -3] + 2];
[ap + 0] = [ap + -3] * 3, ap++;
[ap + 0] = [ap + -5] + [ap + -1], ap++;
[ap + 0] = [fp + -3] + 3, ap++;
[ap + 0] = [[ap + -2] + 0], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 1100})

//! > sierra_code
type SegmentArena = SegmentArena;
type felt252 = felt252;
type Felt252Dict<felt252> = Felt252Dict<felt252>;

libfunc felt252_dict_new<felt252> = felt252_dict_new<felt252>;
libfunc store_temp<SegmentArena> = store_temp<SegmentArena>;
libfunc store_temp<Felt252Dict<felt252>> = store_temp<Felt252Dict<felt252>>;

felt252_dict_new<felt252>([0]) -> ([1], [2]);
store_temp<SegmentArena>([1]) -> ([3]);
store_temp<Felt252Dict<felt252>>([2]) -> ([4]);
return([3], [4]);

test::foo@0([0]: SegmentArena) -> (SegmentArena, Felt252Dict<felt252>);

//! > ==========================================================================

//! > felt252_dict_write libfunc

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(ref dict: Felt252Dict::<felt252>, key: felt252, value: felt252) {
    felt252_dict_write::<felt252>(ref dict, key, value);
}

//! > casm
%{
dict_tracker = __dict_manager.get_tracker(memory[fp + -5])
memory[memory[fp + -5] + 1] = dict_tracker.data[memory[fp + -4]]
dict_tracker.current_ptr += 3
dict_tracker.data[memory[fp + -4]] = memory[fp + -3]
%}
[fp + -4] = [[fp + -5] + 0];
[fp + -3] = [[fp + -5] + 2];
[ap + 0] = [fp + -5] + 3, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 7190})

//! > sierra_code
type felt252 = felt252;
type Felt252Dict<felt252> = Felt252Dict<felt252>;
type Unit = Struct<ut@Tuple>;

libfunc felt252_dict_write<felt252> = felt252_dict_write<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Felt252Dict<felt252>> = store_temp<Felt252Dict<felt252>>;
libfunc store_temp<Unit> = store_temp<Unit>;

felt252_dict_write<felt252>([0], [1], [2]) -> ([3]);
struct_construct<Unit>() -> ([4]);
store_temp<Felt252Dict<felt252>>([3]) -> ([5]);
store_temp<Unit>([4]) -> ([6]);
return([5], [6]);

test::foo@0([0]: Felt252Dict<felt252>, [1]: felt252, [2]: felt252) -> (Felt252Dict<felt252>, Unit);

//! > ==========================================================================

//! > felt252_dict_read libfunc

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(ref dict: Felt252Dict::<felt252>, key: felt252) -> felt252 {
    felt252_dict_read::<felt252>(ref dict, key)
}

//! > casm
%{
dict_tracker = __dict_manager.get_tracker(memory[fp + -4])
dict_tracker.current_ptr += 3
memory[ap + 0] = dict_tracker.data[memory[fp + -3]]
%}
[fp + -3] = [[fp + -4] + 0], ap++;
[ap + -1] = [[fp + -4] + 1];
[ap + -1] = [[fp + -4] + 2];
[ap + 0] = [fp + -4] + 3, ap++;
[ap + 0] = [ap + -2], ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 7390})

//! > sierra_code
type felt252 = felt252;
type Felt252Dict<felt252> = Felt252Dict<felt252>;

libfunc felt252_dict_read<felt252> = felt252_dict_read<felt252>;
libfunc store_temp<Felt252Dict<felt252>> = store_temp<Felt252Dict<felt252>>;
libfunc store_temp<felt252> = store_temp<felt252>;

felt252_dict_read<felt252>([0], [1]) -> ([2], [3]);
store_temp<Felt252Dict<felt252>>([2]) -> ([4]);
store_temp<felt252>([3]) -> ([5]);
return([4], [5]);

test::foo@0([0]: Felt252Dict<felt252>, [1]: felt252) -> (Felt252Dict<felt252>, felt252);

//! > ==========================================================================

//! > felt252_dict_read and felt252_dict_write multiple calls

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(ref dict: Felt252Dict::<felt252>, key: felt252) {
    felt252_dict_read::<felt252>(ref dict, key);
    let a = felt252_dict_read::<felt252>(ref dict, key);
    felt252_dict_write::<felt252>(ref dict, key, a);
    felt252_dict_write::<felt252>(ref dict, key, a);
}

//! > casm
%{
dict_tracker = __dict_manager.get_tracker(memory[fp + -4])
dict_tracker.current_ptr += 3
memory[ap + 0] = dict_tracker.data[memory[fp + -3]]
%}
[fp + -3] = [[fp + -4] + 0], ap++;
[ap + -1] = [[fp + -4] + 1];
[ap + -1] = [[fp + -4] + 2];
%{
dict_tracker = __dict_manager.get_tracker(memory[fp + -4] + 3)
dict_tracker.current_ptr += 3
memory[ap + 0] = dict_tracker.data[memory[fp + -3]]
%}
[fp + -3] = [[fp + -4] + 3], ap++;
[ap + -1] = [[fp + -4] + 4];
[ap + -1] = [[fp + -4] + 5];
%{
dict_tracker = __dict_manager.get_tracker(memory[fp + -4] + 6)
memory[memory[fp + -4] + 6 + 1] = dict_tracker.data[memory[fp + -3]]
dict_tracker.current_ptr += 3
dict_tracker.data[memory[fp + -3]] = memory[ap + -1]
%}
[fp + -3] = [[fp + -4] + 6];
[ap + -1] = [[fp + -4] + 8];
%{
dict_tracker = __dict_manager.get_tracker(memory[fp + -4] + 9)
memory[memory[fp + -4] + 9 + 1] = dict_tracker.data[memory[fp + -3]]
dict_tracker.current_ptr += 3
dict_tracker.data[memory[fp + -3]] = memory[ap + -1]
%}
[fp + -3] = [[fp + -4] + 9];
[ap + -1] = [[fp + -4] + 11];
[ap + 0] = [fp + -4] + 12, ap++;
ret;

//! > function_costs
test::foo: OrderedHashMap({Const: 28660})

//! > sierra_code
type felt252 = felt252;
type Felt252Dict<felt252> = Felt252Dict<felt252>;
type Unit = Struct<ut@Tuple>;

libfunc dup<felt252> = dup<felt252>;
libfunc felt252_dict_read<felt252> = felt252_dict_read<felt252>;
libfunc drop<felt252> = drop<felt252>;
libfunc felt252_dict_write<felt252> = felt252_dict_write<felt252>;
libfunc struct_construct<Unit> = struct_construct<Unit>;
libfunc store_temp<Felt252Dict<felt252>> = store_temp<Felt252Dict<felt252>>;
libfunc store_temp<Unit> = store_temp<Unit>;

dup<felt252>([1]) -> ([1], [4]);
felt252_dict_read<felt252>([0], [4]) -> ([2], [3]);
drop<felt252>([3]) -> ();
dup<felt252>([1]) -> ([1], [7]);
felt252_dict_read<felt252>([2], [7]) -> ([5], [6]);
dup<felt252>([1]) -> ([1], [9]);
dup<felt252>([6]) -> ([6], [10]);
felt252_dict_write<felt252>([5], [9], [10]) -> ([8]);
felt252_dict_write<felt252>([8], [1], [6]) -> ([11]);
struct_construct<Unit>() -> ([12]);
store_temp<Felt252Dict<felt252>>([11]) -> ([13]);
store_temp<Unit>([12]) -> ([14]);
return([13], [14]);

test::foo@0([0]: Felt252Dict<felt252>, [1]: felt252) -> (Felt252Dict<felt252>, Unit);

//! > ==========================================================================

//! > felt252_dict_squash libfunc

//! > test_comments

//! > test_runner_name
SmallE2ETestRunner

//! > cairo
fn foo(dict: Felt252Dict::<felt252>) -> SquashedFelt252Dict::<felt252> {
    felt252_dict_squash::<felt252>(dict)
}

//! > casm
// TODO: this copy is not necessary.
[ap + 0] = [fp + -6], ap++; // rc
[ap + 0] = [fp + -4], ap++; // gas
[ap + 0] = [fp + -5], ap++; // arena
[ap + 0] = [fp + -3], ap++; // end
call main_func;
jmp rel 204;

main_func:
// TODO: remove this copy.
[fp + 2] = [fp + -5], ap++; // gas
ap += 3;
%{
memory[fp + 0] = __segment_index_to_arena_index[
    memory[fp + -3].segment_index
]
%}
[fp + 3] = [arena + -3]; // infos
n_new_dicts = [arena + -2], ap++;
n_destructed_dicts = [arena + -1], ap++;
arena_index = [[fp + -6] + 0];
[ap + 0] = n_new_dicts - 1, ap++;
[ap + 0] = [ap + 1] + arena_index, ap++; // [ap + 1] = n_new_dicts - 1 - arena_index
[ap + 1] = [[fp + -6] + 1];
[ap + 2] = arena_index * 3, ap++;
arena_entry = infos + [ap + 2], ap++;
[arena_entry + 2] = n_destructed_dicts;
end = [arena_entry + 1];
infos = [arena + 0];
n_new_dicts = [arena + 1];
[ap + 4] = n_destructed_dicts + 1, ap++;
[ap + 4] = [arena + 2];
[ap + 5] = [arena_entry + 0], ap++;
end - [ap + 5] = [fp + 1];
[ap + 6] = [fp + -6] + 2, ap++;
[ap + 7] = [arena_entry + 0], ap++;
[ap + 8] = end, ap++;
// last instruction was increase by 8
// args: rc, start, end
call rel with_alloc;

squashed_dict_end - squashed_dict_start = squashed_dict_size, ap++;
dict_size - squashed_dict_size = refund_times_3, ap++;
refund_times_3 / 3 = refund_entries, ap++;
refund_in_gas = refund_entries * 5920, ap++;
[ap + 4] = rc, ap++;
[ap + 5] = gas + refund_in_gas, ap++;
[ap + 6] = arena + 3, ap++;
[ap + 7] = squashed_dict_start, ap++;
[ap + 8] = squashed_dict_end, ap++;
ret;

with_alloc:
ap += 1;
%{ memory[fp + 0] = segments.add() %}
[ap + 0] = [fp + -5], ap++; // rc
[ap + 0] = [fp + -4], ap++; // start
[ap + 0] = [fp + -3], ap++; // end
[ap + 0] = squashed_dict_start, ap++;
call after_alloc;

[ap + 0] = rc, ap++;
[ap + 1] = squashed_dict_start, ap++;
[ap + 2] = squashed_dict_end, ap++;
ret;

after_alloc:
// TODO: end - start was already computed.
end - start = [fp + 0], ap++;
ap += 2;
jmp dict_nonempty if [fp + 0] != 0;
[ap + 0] = [fp + -6], ap++;
[ap + 0] = [fp + -3], ap++;
ret;

dict_nonempty:
[fp + 0] = dict_len * 3, ap++;
%{
dict_access_size = 3
address = memory[fp + -5]
assert memory[fp + 0] % dict_access_size == 0, 'Accesses array size must be divisible by DictAccess.SIZE'
n_accesses = memory[ap + -1]
if '__squash_dict_max_size' in globals():
    assert n_accesses <= __squash_dict_max_size, f'squash_dict() can only be used with n_accesses<={__squash_dict_max_size}. ' f'Got: n_accesses={n_accesses}.'
# A map from key to the list of indices accessing it.
access_indices = {}
for i in range(n_accesses):
    key = memory[address + dict_access_size * i]
    access_indices.setdefault(key, []).append(i)
# Descending list of keys.
keys = sorted(access_indices.keys(), reverse=True)
# Are the keys used bigger than range_check bound.
memory[fp + 2] = 1 if keys[0] >= range_check_builtin.bound else 0
memory[fp + 1] = key = keys.pop()
%}
jmp big_keys2 if big_keys != 0, ap++;
[fp + 1] = [[fp + -6] + 0]; // range-check first key.
[ap + 1] = [fp + -6] + 1;
jmp continue;

big_keys2:
[ap + 1] = [fp + -6];

continue:
[ap + 2] = [fp + -5], ap++;
[ap + 3] = end - 1, ap++;
[ap + 4] = first_key, ap++;
[ap + 5] = dict_len, ap++;
[ap + 6] = squashed_dict_start, ap++;
[ap + 7] = big_keys, ap++;
call inner;
// TODO: the following instructions are not necessary.
[ap + 0] = [ap + -2], ap++;
[ap + 0] = [ap + -2], ap++;
ret;

// ---------------------
// inner
// ---------------------

[fp - 9] = range_check_ptr
[fp - 8] = dict_start
[fp - 7] = dict_end - 1
[fp - 6] = key
[fp - 5] = remaining_accesses_before
[fp - 4] = squashed_dict_ptr (current)
[fp - 3] = big_keys
[fp + 6] = remaining_accesses_new


ap += 5;
%{
current_access_indices = sorted(access_indices[key])[::-1]
current_access_index = current_access_indices.pop()
memory[memory[fp + -9]] = current_access_index
%}
[ap + 2] = [initial_range_check + 0], ap++;
[ap + 3] = [ap + 2] * 3, ap++;
entry = dict_start + [ap + 3], ap++;
[ap + 7] = entry.new, ap++;
[ap + 8] = initial_range_check + 1, ap++;
key = [entry + 0], ap++;
key = squashed_dict[0].key, ap++;
0 = entry.prev, ap++;
0 = squashed_dict[0].prev, ap++;
0 = 0;

// ap + 6 = entry

%{ memory[ap + 5] = 0 if current_access_indices else 1 %}
jmp rel 15 if [ap + 5] != 0;
// cost of far 12

loop:

%{
new_access_index = current_access_indices.pop()
memory[ap + 0] = new_access_index - current_access_index - 1
current_access_index = new_access_index
%}

index_diff = [range_check_ptr + 0], ap++;
[ap + 1] = index_diff + 1, ap++;
[ap + 2] = [ap + 1] * 3, ap++;
ptr2 = ptr + [ap + 2], ap++;
prev_value = [ptr2 + 1], ap++;
prev_value2 = new_value = [ptr2 + 2], ap++;
key = [ptr2 + 0], ap++;
range_check_ptr2 = range_check_ptr + 1

%{ memory[ap + -4] = 1 if current_access_indices else 0 %}
jmp loop if [ap + -4] != 0;



%{ assert len(current_access_indices) == 0 %}
[ap + 0] = [fp + -7] - [ap + -3] , ap++;
[ap + 0] = [[ap + -1] + 0];

n_accesses = [ap + -1] - [fp + -9], ap++;
%{ assert memory[ap + -1] == len(access_indices[key]) %}
[ap + -2] = squashed_dict[0].new;
remaining_accesses_new = remaining_accesses - n_accesses;
jmp more_keys if remaining_accesses_new != 0;
%{ assert len(keys) == 0 %}
new_range_check_ptr = [ap + -1] + 1, ap++;
new_squashed_dict = &squashed_dict[1], ap++;
ret;

more_keys:
%{ assert len(keys) > 0, 'No keys left but remaining_accesses > 0.'
memory[fp + 5] = key = keys.pop()
 %}
jmp rel 14 if big_keys != 0;
[ap + 0] = [fp + -6] + 1, ap++;
key_diff = [range_check + 1];
new_key = key_diff + [ap + 0], ap++;
// TODO: not necessary to copy to local variables?
[fp + 0] = range_check + 2;
[fp + 1] = [fp + -8];
[fp + 2] = [fp + -7];
[fp + 3] = new_key;
[fp + 4] = remaining_accesses_new;
jmp rel 53;

big_keys:
%{
from starkware.cairo.common.math_utils import assert_integer
assert_integer(memory[fp + -6])
assert_integer(memory[fp + 5])
assert (memory[fp + -6] % PRIME) < (memory[fp + 5] % PRIME), f'a = {memory[fp + -6] % PRIME} is not less than b = {memory[fp + 5] % PRIME}.'
%}
key = key_diff + new_key, ap++;
jmp rel 6 if key_diff != 0, ap++;
key = key + 1;
jmp rel 3;
[ap + 1] = key;
%{
import itertools

from starkware.cairo.common.math_utils import assert_integer
assert_integer(memory[ap + -1])
assert_integer(memory[fp + 5])
a = memory[ap + -1] % PRIME
b = memory[fp + 5] % PRIME
assert a <= b, f'a = {a} is not less than or equal to b = {b}.'

# Find an arc less than PRIME / 3, and another less than PRIME / 2.
lengths_and_indices = [(a, 0), (b - a, 1), (PRIME - 1 - b, 2)]
lengths_and_indices.sort()
assert lengths_and_indices[0][0] <= PRIME // 3 and lengths_and_indices[1][0] <= PRIME // 2
excluded = lengths_and_indices[2][1]

memory[memory[fp + -9] + 1], memory[memory[fp + -9] + 0] = (
    divmod(lengths_and_indices[0][0], 3544607988759775765608368578435044694))
memory[memory[fp + -9] + 3], memory[memory[fp + -9] + 2] = (
    divmod(lengths_and_indices[1][0], 5316911983139663648412552867652567041))
%}
[ap + 2] = [[fp + -9] + 0], ap++;
[ap + 3] = [[fp + -9] + 1], ap++;
[ap + 4] = [ap + 3] * 5316911983139663648412552867652567041, ap++;
[ap + 5] = [ap + 2] + [ap + 4], ap++;
[ap + 6] = [[fp + -9] + 2], ap++;
[ap + 7] = [[fp + -9] + 3], ap++;
[ap + 8] = [ap + 7] * 3544607988759775765608368578435044694, ap++;
[ap + 9] = [ap + 6] + [ap + 8], ap++;
[ap + 10] = [ap + 5] + [ap + 9], ap++;
[ap + 11] = [ap + 5] * [ap + 9], ap++;
// ap + 12 for the next line

%{ memory[ap + 0] = 1 if excluded != 0 else 0 %}
jmp rel 12 if [ap + 12] != 0, ap++;
[ap + 13] = key * -1, ap++;
[ap + 10] = [ap + 13] + -1; // (PRIME - 1) - key
key - new_key = [ap + 14], ap++; // key - new_key
[ap + 15] = new_key + 1, ap++; // new_key + 1
[ap + 11] = [ap + 14] * [ap + 15]; // (new_key - key) * (PRIME -1 - new_key)
jmp finish_big_key;

// add 13
%{ memory[ap + 0] = 1 if excluded != 1 else 0 %}
jmp rel 10 if [ap + 13] != 0, ap++;
[ap + 14] = new_key * -1, ap++; // -new_key
[ap + 15] = [ap + 14] + -1, ap++; // -new_key - 1
[ap + 10] = [ap + 1] + [ap + 15]; // key + ((PRIME - 1) - new_key)
[ap + 11] = [ap + 1] * [ap + 15]; // key * ((PRIME - 1) - new_key)
jmp finish_big_key;

%{ assert excluded == 2 %}
[ap + 10] = new_key, ap++;
new_key - key = [ap + 15], ap++;
[ap + 11] = [ap + 1] * [ap + 15]; // key * (new_key - key)

finish_big_key:
[fp + 0] = [fp + -9] + 4;
[fp + 1] = [fp + -8];
[fp + 2] = [fp + -7];
[fp + 3] = new_key;
[fp + 4] = [fp + 6];

//////////////////////

end_small_keys:
[ap + 0] = [fp + 0], ap++;
[ap + 0] = [fp + 1], ap++;
[ap + 0] = [fp + 2], ap++;
[ap + 0] = [fp + 3], ap++;
[ap + 0] = [fp + 4], ap++;
[ap + 0] = &squashed_dict[1], ap++;
[ap + 0] = big_keys, ap++;
call inner;
ret;

[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -4], ap++;
[ap + 0] = [ap + -6], ap++;
[ap + 0] = [ap + -5], ap++;
[ap + 0] = [ap + -5], ap++;
ret;



//! > function_costs
test::foo: OrderedHashMap({Const: 8210})

//! > sierra_code
type RangeCheck = RangeCheck;
type GasBuiltin = GasBuiltin;
type SegmentArena = SegmentArena;
type felt252 = felt252;
type Felt252Dict<felt252> = Felt252Dict<felt252>;
type SquashedFelt252Dict<felt252> = SquashedFelt252Dict<felt252>;

libfunc disable_ap_tracking = disable_ap_tracking;
libfunc felt252_dict_squash<felt252> = felt252_dict_squash<felt252>;
libfunc store_temp<RangeCheck> = store_temp<RangeCheck>;
libfunc store_temp<SegmentArena> = store_temp<SegmentArena>;
libfunc store_temp<GasBuiltin> = store_temp<GasBuiltin>;
libfunc store_temp<SquashedFelt252Dict<felt252>> = store_temp<SquashedFelt252Dict<felt252>>;

disable_ap_tracking() -> ();
felt252_dict_squash<felt252>([0], [2], [1], [3]) -> ([4], [5], [6], [7]);
store_temp<RangeCheck>([4]) -> ([8]);
store_temp<SegmentArena>([6]) -> ([9]);
store_temp<GasBuiltin>([5]) -> ([10]);
store_temp<SquashedFelt252Dict<felt252>>([7]) -> ([11]);
return([8], [9], [10], [11]);

test::foo@0([0]: RangeCheck, [1]: SegmentArena, [2]: GasBuiltin, [3]: Felt252Dict<felt252>) -> (RangeCheck, SegmentArena, GasBuiltin, SquashedFelt252Dict<felt252>);
